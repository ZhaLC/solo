10.1.死锁概念
    多线程运行过程中，因争夺资源造成的一种僵局状态
    举个栗子：
        线程A，按照a->b顺序获得锁，线程B，按照b->a顺序获得锁，此时就会造成死锁
10.2.产生死锁的原因？
    通常由于通信顺序不当的不同线程间的资源竞争
10.3.产生死锁的4个必要条件？
    互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用
	请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放
	不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放
	环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链
10.4.预防死锁？
    以确定的顺序获得锁
    Lock锁的超时放弃策略
    银行家算法(避免死锁)：
        思想：
            主要是银行的贷款业务，
        1.假设 P1 进程提出请求 K 个资源
        2.如果 K <= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源
        3.如果 K <= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 Available
        4.系统试探分配资源，并修改下列数据
            Available = Available - K；表示分配给 P1 K 个资源后，还剩多少系统可分配资源
            Allocation = Allocation + K；表示 P1 已经获得的资源
            Need = Need - K；表示进程 P1 还需要获得的资源
        5.此时系统执行安全性算法，计算进程是否处于安全性状态
    注：
        安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态。银行家算法是
        计算某一个进程对资源的需求问题，安全性算法是计算所有的进程在各自的银行家算法执行
        下，是否处于**安全状态**。
    预防死锁，避免死锁，检测死锁和解除死锁
10.5.java中的15种锁？
    公平锁、非公平锁、可重入锁、不可重入锁、独享锁、共享锁、互斥锁、读写锁、乐观锁、悲观锁、分段锁、偏向锁、轻量级锁、重量级锁、自旋锁

    公平锁：是指多个线程按照申请锁的顺序来获取锁
    非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序
    注：ReentrantLock可通过构造函数，指定是否为公平锁，Synchronized不公平锁，无法修改状态
    可重入锁：指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁 (前提得是同一个对象或者class)
    注：ReentrantLock和synchronized都是可重入锁
    独享锁：该锁每一次只能被一个线程所持有     Synchronized独享锁
    共享锁：该锁可被多个线程共有             ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占
    自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环